<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø² Ú©Ø±ÙˆÙ†â€ŒØ¬Ø§Ø¨</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --container-bg: white;
            --text-color: #333;
            --border-color: #ddd;
            --control-bg: #f8f9fa;
            --shadow-color: rgba(0,0,0,0.1);
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --safe-color: #28a745;
            --critical-color: #ffc107;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
        }

        body.dark-mode {
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --border-color: #444;
            --control-bg: #2a2a2a;
            --shadow-color: rgba(0,0,0,0.4);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 20px;
            background: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--container-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px var(--shadow-color);
            border: 1px solid var(--border-color);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        h1 { margin: 0; }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        fieldset {
            background: var(--control-bg);
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 8px;
        }

        legend {
            font-weight: bold;
            padding: 0 10px;
            color: var(--primary-color);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .control-group label {
            font-weight: 500;
        }
        
        input[type="number"], select {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--container-bg);
            color: var(--text-color);
            width: 100%;
            box-sizing: border-box;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-group input[type="range"] {
            flex-grow: 1;
        }
        
        button {
            padding: 10px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        button:hover { background: var(--primary-hover); }

        .button-group {
            display: flex;
            gap: 10px;
            grid-column: 1 / -1; /* Span all columns */
            margin-top: 10px;
        }
        
        .formula-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        .formula-box h3 {
            grid-column: 1 / -1;
            margin: 0 0 10px 0;
            text-align: center;
        }
        .formula-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        .formula-text {
            font-size: 14px;
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .formula-description {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.85);
            margin: 5px 0 10px 0;
            flex-grow: 1; /* Allows items to have same height */
        }
        .formula-result {
            font-size: 18px; font-weight: bold; padding: 5px 10px; border-radius: 4px;
        }
        .result-safe { background: var(--safe-color); color: white; }
        .result-critical { background: var(--critical-color); color: #212529; }
        .result-danger { background: var(--danger-color); color: white; }
        
        .timeline-container {
            width: 100%;
            overflow-x: hidden; /* Managed by JS */
            cursor: grab;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
        }
        .timeline {
            height: 150px;
            position: relative;
            background: linear-gradient(to right, var(--control-bg) 0%, var(--container-bg) 100%);
        }
        
        .cron-execution {
            position: absolute; width: 3px; background: var(--danger-color); top: 25px; height: calc(100% - 25px); z-index: 4;
        }
        .processing-window {
            position: absolute; background: rgba(40, 167, 69, 0.2); border: 1px dashed var(--safe-color); top: 25px; height: calc(100% - 25px); z-index: 1;
        }
        .processing-bar {
            position: absolute; background: rgba(23, 162, 184, 0.6); border: 1px solid var(--info-color); top: 35px; height: 10px; z-index: 2;
        }
        .record {
            position: absolute; width: 10px; height: 10px; border-radius: 50%; top: 60px; z-index: 3; transform: translateX(-50%);
        }
        .record.pending { background: var(--critical-color); border: 2px solid #ff6b35; }
        .record.processed { background: var(--safe-color); border: 2px solid #155724; }
        .record.missed { background: var(--danger-color); border: 2px solid #721c24; animation: pulse 1s infinite; }
        .queue-size-bar {
            position: absolute; background: rgba(255, 193, 7, 0.4); border-top: 2px solid var(--critical-color); bottom: 0; z-index: 0;
        }
        
        .stats-logs-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .stats, .event-log {
            background: var(--control-bg); padding: 15px; border-radius: 8px;
        }
        .event-log pre {
            max-height: 200px; overflow-y: auto; background: var(--bg-color); padding: 10px; border-radius: 4px; font-size: 12px;
        }
        .stat-item { display: flex; justify-content: space-between; margin: 8px 0; }
        
        .tooltip {
            position: fixed; background: #333; color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 9999; display: none; white-space: pre; pointer-events: none;
        }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø² Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ú©Ø±ÙˆÙ† Ø¬Ø§Ø¨</h1>
            <button id="darkModeToggle">ğŸŒ™ Ø­Ø§Ù„Øª ØªØ§Ø±ÛŒÚ©</button>
        </div>
        
        <div class="controls">
            <fieldset>
                <legend>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¹Ù…ÙˆÙ…ÛŒ Ú©Ø±ÙˆÙ†</legend>
                 <div class="control-group">
                    <label for="jobType">Ù†ÙˆØ¹ ÙˆØ¸ÛŒÙÙ‡ (Job Type):</label>
                    <select id="jobType">
                        <option value="timeWindow" selected>Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¨Ø§Ø²Ù‡ Ø²Ù…Ø§Ù†ÛŒ (Time Window)</option>
                        <option value="queue">Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµÙ (Queue)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="cronInterval">ÙØ§ØµÙ„Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø±ÙˆÙ† (Ø¯Ù‚ÛŒÙ‚Ù‡): <span id="cronIntervalValue">5</span></label>
                    <div class="slider-group">
                        <input type="range" id="cronInterval" value="5" min="1" max="60">
                        <input type="number" id="cronIntervalNumber" value="5" min="1" max="60">
                    </div>
                </div>
                 <div class="control-group">
                    <label for="processingDuration">Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ù¾Ø±Ø¯Ø§Ø²Ø´ (Ø¯Ù‚ÛŒÙ‚Ù‡): <span id="processingDurationValue">2</span></label>
                    <div class="slider-group">
                        <input type="range" id="processingDuration" value="2" min="0" max="30" step="0.5">
                        <input type="number" id="processingDurationNumber" value="2" min="0" max="30" step="0.5">
                    </div>
                </div>
                 <div class="control-group">
                    <label for="concurrencyMode">Ø±ÙØªØ§Ø± Ø¯Ø± Ø²Ù…Ø§Ù† ØªØ¯Ø§Ø®Ù„ Ø§Ø¬Ø±Ø§:</label>
                    <select id="concurrencyMode">
                        <option value="skip" selected>Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ† (Skip)</option>
                        <option value="queue">ØµÙ (Queue)</option>
                    </select>
                </div>
                 <div class="control-group">
                    <label for="jitter">Ø­Ø¯Ø§Ú©Ø«Ø± ØªØ£Ø®ÛŒØ± ØªØµØ§Ø¯ÙÛŒ (Jitter): <span id="jitterValue">0</span></label>
                    <div class="slider-group">
                        <input type="range" id="jitter" value="0" min="0" max="5" step="0.1">
                        <input type="number" id="jitterNumber" value="0" min="0" max="5" step="0.1">
                    </div>
                </div>
            </fieldset>

            <div id="timeWindowSettings">
                <fieldset>
                    <legend>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²Ù‡ Ù¾Ø±Ø¯Ø§Ø²Ø´</legend>
                    <div class="control-group">
                        <label for="processStart">Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²Ù‡ Ù¾Ø±Ø¯Ø§Ø²Ø´ (Ø¯Ù‚ÛŒÙ‚Ù‡ Ù¾ÛŒØ´): <span id="processStartValue">7</span></label>
                        <div class="slider-group">
                             <input type="range" id="processStart" value="7" min="1" max="60">
                             <input type="number" id="processStartNumber" value="7" min="1" max="60">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="processEnd">Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²Ù‡ Ù¾Ø±Ø¯Ø§Ø²Ø´ (Ø¯Ù‚ÛŒÙ‚Ù‡ Ù¾ÛŒØ´): <span id="processEndValue">10</span></label>
                        <div class="slider-group">
                            <input type="range" id="processEnd" value="10" min="1" max="60">
                            <input type="number" id="processEndNumber" value="10" min="1" max="60">
                        </div>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§ÛŒ Ø¨Ø§Ø²Ù‡ Ø²Ù…Ø§Ù†ÛŒ</legend>
                    <div class="control-group">
                        <label for="recordCount">ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§:</label>
                        <input type="number" id="recordCount" value="80" min="10" max="500">
                    </div>
                    <div class="control-group">
                        <label for="recordDistribution">Ø§Ù„Ú¯ÙˆÛŒ ØªÙˆØ²ÛŒØ¹ Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§:</label>
                        <select id="recordDistribution">
                            <option value="uniform" selected>ÛŒÚ©Ù†ÙˆØ§Ø®Øª (Uniform)</option>
                            <option value="bursty">Ø®ÙˆØ´Ù‡â€ŒØ§ÛŒ (Bursty)</option>
                            <option value="normal">Ù†Ø±Ù…Ø§Ù„ (Normal)</option>
                        </select>
                    </div>
                </fieldset>
            </div>

            <fieldset id="queueSettings" style="display: none;">
                <legend>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµÙ</legend>
                <div class="control-group">
                    <label for="recordsPerMinute">Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ø¨Ù‡ ØµÙ (Ø¯Ø± Ø¯Ù‚ÛŒÙ‚Ù‡):</label>
                    <input type="number" id="recordsPerMinute" value="15" min="1" max="500">
                </div>
                <div class="control-group">
                    <label for="processingCapacity">Ø¸Ø±ÙÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø± Ù‡Ø± Ø§Ø¬Ø±Ø§ (ØªØ¹Ø¯Ø§Ø¯ Ø±Ú©ÙˆØ±Ø¯):</label>
                    <input type="number" id="processingCapacity" value="50" min="1" max="1000">
                </div>
            </fieldset>

            <fieldset>
                 <legend>ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ</legend>
                 <div class="control-group">
                    <label for="simulationTime">Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ (Ø¯Ù‚ÛŒÙ‚Ù‡):</label>
                    <input type="number" id="simulationTime" value="60" min="30" max="500">
                </div>
            </fieldset>
            
            <div class="button-group">
                 <button onclick="runFullSimulation(false)">ğŸ”„ Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø¬Ø¯Ø¯ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ</button>
                 <button onclick="runFullSimulation(true)">ğŸ² ØªÙˆÙ„ÛŒØ¯ Ø±Ú©ÙˆØ±Ø¯/Ø³Ù†Ø§Ø±ÛŒÙˆ Ø¬Ø¯ÛŒØ¯ Ùˆ Ø§Ø¬Ø±Ø§</button>
                 <button id="exportJson">ğŸ“„ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù†ØªØ§ÛŒØ¬ (JSON)</button>
            </div>
        </div>
        
           <div class="formula-box" id="formulaBox">
                <!-- Content will be generated by JS -->
           </div>
        
        <div class="timeline-container" id="timelineContainer">
            <div class="timeline" id="timeline"></div>
        </div>
        
        <div class="stats-logs-container">
            <div class="stats" id="stats">
                <!-- Content will be generated by JS -->
            </div>
            <div class="event-log">
                <h3>Ù„Ø§Ú¯ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§</h3>
                <pre id="eventLogContent">Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù„Ø§Ú¯ØŒ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø±Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯.</pre>
            </div>
        </div>
    </div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // DOM Elements
        const elements = {};
        const ids = [
            'jobType', 'cronInterval', 'cronIntervalValue', 'cronIntervalNumber', 'processingDuration', 'processingDurationValue', 'processingDurationNumber',
            'concurrencyMode', 'processStart', 'processStartValue', 'processStartNumber', 'processEnd', 'processEndValue', 'processEndNumber',
            'recordCount', 'simulationTime', 'recordDistribution', 'jitter', 'jitterValue', 'jitterNumber',
            'formulaBox', 'timelineContainer', 'timeline', 'stats',
            'eventLogContent', 'tooltip', 'darkModeToggle', 'exportJson',
            'timeWindowSettings', 'queueSettings', 'recordsPerMinute', 'processingCapacity'
        ];
        ids.forEach(id => elements[id] = document.getElementById(id));

        // Global State
        let records = [];
        let simulationResults = {};
        let timelineState = { zoom: 1, pan: 0, isDragging: false, startX: 0 };

        // --- Configuration Reading ---
        function getConfig() {
            const config = {
                jobType: elements.jobType.value,
                cronInterval: parseFloat(elements.cronInterval.value),
                simulationTime: parseInt(elements.simulationTime.value),
                processingDuration: parseFloat(elements.processingDuration.value),
                concurrencyMode: elements.concurrencyMode.value,
                jitter: parseFloat(elements.jitter.value)
            };
            
            if (config.jobType === 'timeWindow') {
                config.processStart = parseFloat(elements.processStart.value);
                config.processEnd = parseFloat(elements.processEnd.value);
                config.recordCount = parseInt(elements.recordCount.value);
                config.recordDistribution = elements.recordDistribution.value;
            } else { // queue
                config.recordsPerMinute = parseInt(elements.recordsPerMinute.value);
                config.processingCapacity = parseInt(elements.processingCapacity.value);
            }
            return config;
        }

        // --- Core Simulation Logic ---
        function generateTimeWindowRecords(config) {
            records = [];
            for (let i = 0; i < config.recordCount; i++) {
                let time;
                switch (config.recordDistribution) {
                    case 'normal':
                        let u, v;
                        do { u = Math.random() * 2 - 1; v = Math.random() * 2 - 1; } while (u * u + v * v >= 1);
                        let rand_std = u * Math.sqrt(-2 * Math.log(u * u + v * v) / (u * u + v * v));
                        let rand_norm = (config.simulationTime / 2) + (config.simulationTime / 6) * rand_std;
                        time = Math.max(0, Math.min(config.simulationTime, rand_norm));
                        break;
                    case 'bursty':
                        const numBursts = Math.max(2, Math.floor(config.simulationTime / 20));
                        const burstCenter = (Math.floor(Math.random() * numBursts) + 1) * (config.simulationTime / (numBursts + 1));
                        time = burstCenter + (Math.random() - 0.5) * (config.simulationTime / 10);
                        time = Math.max(0, Math.min(config.simulationTime, time));
                        break;
                    default:
                        time = Math.random() * config.simulationTime;
                        break;
                }
                records.push({ id: i, time: time, status: 'pending' });
            }
            records.sort((a, b) => a.time - b.time);
        }

        function runTimeWindowSimulation(config) {
            records.forEach(r => r.status = 'pending');
            
            const results = {
                executions: [],
                processedRecords: new Set(),
                missedRecords: new Set(),
                logs: [],
                skippedRuns: 0
            };

            let processingEndTime = 0;
            
            for (let time = config.cronInterval; time <= config.simulationTime; time += config.cronInterval) {
                const actualExecTime = time + (Math.random() * config.jitter);
                let processingStartTime = actualExecTime;

                if (config.concurrencyMode === 'skip' && actualExecTime < processingEndTime) {
                    results.skippedRuns++;
                    results.logs.push(`[${actualExecTime.toFixed(1)}] ğŸƒâ€â™‚ï¸ CRON SKIPPED due to ongoing process.`);
                    continue;
                }
                
                if (config.concurrencyMode === 'queue' && actualExecTime < processingEndTime) {
                    processingStartTime = processingEndTime;
                     results.logs.push(`[${actualExecTime.toFixed(1)}] ğŸ•’ CRON QUEUED. Will start at ${processingStartTime.toFixed(1)}.`);
                }
                
                const currentProcessingEndTime = processingStartTime + config.processingDuration;
                processingEndTime = currentProcessingEndTime;

                const windowStart = actualExecTime - config.processEnd;
                const windowEnd = actualExecTime - config.processStart;
                
                const executionData = {
                    scheduledTime: time,
                    actualTime: actualExecTime,
                    processingStartTime: processingStartTime,
                    processingEndTime: currentProcessingEndTime,
                    window: [windowStart, windowEnd],
                    processed: []
                };

                results.logs.push(`[${actualExecTime.toFixed(1)}] âš¡ï¸ CRON EXECUTED. Window: [${windowStart.toFixed(1)}, ${windowEnd.toFixed(1)}]`);

                records.forEach(record => {
                    if (record.status === 'pending' && record.time >= windowStart && record.time < windowEnd) {
                        record.status = 'processed';
                        results.processedRecords.add(record.id);
                        executionData.processed.push(record.id);
                        results.logs.push(`  - âœ… Record #${record.id} at ${record.time.toFixed(1)} processed.`);
                    }
                });
                results.executions.push(executionData);
            }

            const finalSafeTime = results.executions.length > 0 ? results.executions[results.executions.length - 1].actualTime - config.processStart : config.simulationTime;
            records.forEach(record => {
                if (record.status === 'pending' && record.time < finalSafeTime) {
                    record.status = 'missed';
                    results.missedRecords.add(record.id);
                     results.logs.push(`[${record.time.toFixed(1)}] âŒ Record #${record.id} MISSED.`);
                }
            });

            return results;
        }

        function runQueueSimulation(config) {
            let queueSize = 0;
            let totalAdded = 0;
            let totalProcessed = 0;
            let maxQueueSize = 0;
            let processingEndTime = 0;
            
            const results = {
                executions: [],
                logs: [],
                skippedRuns: 0,
                queueSnapshots: []
            };
            
            for (let t = 1; t <= config.simulationTime; t++) {
                const addedThisMinute = config.recordsPerMinute; // Simplified: constant rate
                queueSize += addedThisMinute;
                totalAdded += addedThisMinute;
                if (queueSize > maxQueueSize) maxQueueSize = queueSize;
                
                if (t % config.cronInterval === 0) {
                    const scheduledTime = t;
                    const actualExecTime = scheduledTime + (Math.random() * config.jitter);
                    let processingStartTime = actualExecTime;
                    
                    if (config.concurrencyMode === 'skip' && actualExecTime < processingEndTime) {
                        results.skippedRuns++;
                        results.logs.push(`[${actualExecTime.toFixed(1)}] ğŸƒâ€â™‚ï¸ CRON SKIPPED. Queue size: ${queueSize}`);
                        continue;
                    }
                    if (config.concurrencyMode === 'queue' && actualExecTime < processingEndTime) {
                        processingStartTime = processingEndTime;
                        results.logs.push(`[${actualExecTime.toFixed(1)}] ğŸ•’ CRON QUEUED. Will start at ${processingStartTime.toFixed(1)}. Queue size: ${queueSize}`);
                    }

                    const currentProcessingEndTime = processingStartTime + config.processingDuration;
                    processingEndTime = currentProcessingEndTime;
                    
                    const processedThisRun = Math.min(queueSize, config.processingCapacity);
                    queueSize -= processedThisRun;
                    totalProcessed += processedThisRun;

                    const executionData = {
                        scheduledTime: scheduledTime,
                        actualTime: actualExecTime,
                        processingStartTime: processingStartTime,
                        processingEndTime: currentProcessingEndTime,
                        processedCount: processedThisRun,
                        queueSizeBefore: queueSize + processedThisRun
                    };
                    results.executions.push(executionData);
                    results.queueSnapshots.push({ time: scheduledTime, size: queueSize + processedThisRun });
                    results.logs.push(`[${actualExecTime.toFixed(1)}] âš¡ï¸ CRON EXECUTED. Processed ${processedThisRun} items. Queue size: ${queueSize}`);
                }
            }
            
            results.totalAdded = totalAdded;
            results.totalProcessed = totalProcessed;
            results.finalQueueSize = queueSize;
            results.maxQueueSize = maxQueueSize;
            return results;
        }


        // --- UI Update Functions ---
        function updateUI(config, results) {
            updateFormulas(config, results);
            updateStats(config, results);
            drawTimeline(config, results);
            updateEventLog(results.logs);
        }

        function setStatus(val, danger, critical) {
            if (danger(val)) return 'formula-result result-danger';
            if (critical(val)) return 'formula-result result-critical';
            return 'formula-result result-safe';
        }

        // ########### MODIFIED SECTION START ###########
        function updateFormulas(config, results) {
            let html = `<h3>ğŸ§® ØªØ­Ù„ÛŒÙ„ ÙØ±Ù…ÙˆÙ„ÛŒ Ùˆ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø±ÛŒØ³Ú©</h3>`;

            const concurrencyRisk = config.processingDuration > config.cronInterval;
            const concurrencyRiskClass = setStatus(concurrencyRisk, v => v, () => false);
            
            if (config.jobType === 'timeWindow') {
                const gap = (config.cronInterval + config.processStart) - config.processEnd;
                const maxSafe = config.processEnd - config.processStart;
                const totalProcessed = results.processedRecords ? results.processedRecords.size : 0;
                const totalExecutions = results.executions ? results.executions.length : 0;
                const avgLoad = totalExecutions > 0 ? (totalProcessed / totalExecutions).toFixed(1) : 0;

                html += `
                    <div class="formula-item" title="Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ù†Ø´Ø§Ù†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ 'Ø´Ú©Ø§Ù Ø²Ù…Ø§Ù†ÛŒ' Ø¨ÛŒÙ† Ø¨Ø§Ø²Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø³Øª. Ø§Ú¯Ø± Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ù…Ø«Ø¨Øª Ø¨Ø§Ø´Ø¯ØŒ ÛŒÚ© Ø´Ú©Ø§Ù Ø¨Ù‡ ÙˆØ¬ÙˆØ¯ Ù…ÛŒâ€ŒØ¢ÛŒØ¯ Ú©Ù‡ Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ Ø¢Ù† Ù‡Ø±Ú¯Ø² Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù†Ø®ÙˆØ§Ù‡Ù†Ø¯ Ø´Ø¯. Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø§Ù…Ù„ØŒ Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ø¨Ø§ÛŒØ¯ ØµÙØ± ÛŒØ§ Ù…Ù†ÙÛŒ Ø¨Ø§Ø´Ø¯.">
                        <span class="formula-text">Ø´Ú©Ø§Ù Ù¾Ø±Ø¯Ø§Ø²Ø´ (Gap)</span>
                        <p class="formula-description">Ø¢ÛŒØ§ Ø²Ù…Ø§Ù†ÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ Ú©Ù‡ Ù‡ÛŒÚ† Ú©Ø±ÙˆÙ†ÛŒ Ø¢Ù† Ø±Ø§ Ù¾ÙˆØ´Ø´ Ù†Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ØŸ</p>
                        <div class="${setStatus(gap, v => v > 0, v => v === 0)}">${gap.toFixed(1)}</div>
                    </div>
                    <div class="formula-item" title="Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ø¨ÛŒØ´ØªØ±ÛŒÙ† ÙØ§ØµÙ„Ù‡ Ø²Ù…Ø§Ù†ÛŒ Ø§Ø³Øª Ú©Ù‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨ÛŒÙ† Ø¯Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø±ÙˆÙ† Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒØ¯ Ø¨Ø¯ÙˆÙ† Ø§ÛŒÙ†Ú©Ù‡ Ù‡ÛŒÚ† Ø±Ú©ÙˆØ±Ø¯ÛŒ Ø§Ø² Ø¯Ø³Øª Ø¨Ø±ÙˆØ¯. ÙØ§ØµÙ„Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø±ÙˆÙ† Ø´Ù…Ø§ Ø¨Ø§ÛŒØ¯ Ú©Ù…ØªØ± ÛŒØ§ Ù…Ø³Ø§ÙˆÛŒ Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ø¨Ø§Ø´Ø¯. Ø§ÛŒÙ† Ù…Ù‚Ø¯Ø§Ø± Ù…Ø¹Ø§Ø¯Ù„ Ø·ÙˆÙ„ Ù¾Ù†Ø¬Ø±Ù‡ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ù…Ø§ (End - Start) Ø§Ø³Øª.">
                        <span class="formula-text">Ø­Ø¯Ø§Ú©Ø«Ø± ÙØ§ØµÙ„Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Ø§ÛŒÙ…Ù†</span>
                        <p class="formula-description">Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø´Ú©Ø§ÙØŒ ÙØ§ØµÙ„Ù‡ Ú©Ø±ÙˆÙ† Ø­Ø¯Ø§Ú©Ø«Ø± Ú†Ù‚Ø¯Ø± Ø¨Ø§ÛŒØ¯ Ø¨Ø§Ø´Ø¯ØŸ</p>
                        <div class="${setStatus(config.cronInterval, v => v > maxSafe, v => v === maxSafe)}">${maxSafe.toFixed(1)}</div>
                    </div>
                    <div class="formula-item" title="Ø§ÛŒÙ† ÙˆØ¶Ø¹ÛŒØª Ø²Ù…Ø§Ù†ÛŒ 'Ø®Ø·Ø±Ù†Ø§Ú©' Ø§Ø³Øª Ú©Ù‡ 'Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ù¾Ø±Ø¯Ø§Ø²Ø´' Ø§Ø² 'ÙØ§ØµÙ„Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø±ÙˆÙ†' Ø¨ÛŒØ´ØªØ± Ø¨Ø§Ø´Ø¯. Ø§ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù…Ù†Ø¬Ø± Ø¨Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Ù‡Ù…Ø²Ù…Ø§Ù† Ú©Ø±ÙˆÙ†â€ŒÙ‡Ø§ØŒ Ù…ØµØ±Ù Ø¨ÛŒØ´ Ø§Ø² Ø­Ø¯ Ù…Ù†Ø§Ø¨Ø¹ Ø³Ø±ÙˆØ± ÛŒØ§ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø´ÙˆØ¯.">
                        <span class="formula-text">Ø±ÛŒØ³Ú© Ø§Ø¬Ø±Ø§ÛŒ Ù‡Ù…Ø²Ù…Ø§Ù†</span>
                        <p class="formula-description">Ø¢ÛŒØ§ Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø§ØªÙ…Ø§Ù… Ø§Ø¬Ø±Ø§ÛŒ ÙØ¹Ù„ÛŒ Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŸ</p>
                         <div class="${concurrencyRiskClass}">${concurrencyRisk ? 'Ø®Ø·Ø±Ù†Ø§Ú© âš ï¸' : 'Ø§ÛŒÙ…Ù† âœ…'}</div>
                    </div>
                    <div class="formula-item" title="Ø§ÛŒÙ† Ù…Ø¹ÛŒØ§Ø± Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ØªØ¹Ø¯Ø§Ø¯ Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§ÛŒÛŒ Ø§Ø³Øª Ú©Ù‡ Ø¯Ø± Ù‡Ø± Ø§Ø¬Ø±Ø§ÛŒ Ù…ÙˆÙÙ‚ Ú©Ø±ÙˆÙ† Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ø¨Ù‡ Ø´Ù…Ø§ Ú©Ù…Ú© Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ø¸Ø±ÙÛŒØª Ø³ÛŒØ³ØªÙ… Ø®ÙˆØ¯ Ø±Ø§ ØªØ®Ù…ÛŒÙ† Ø¨Ø²Ù†ÛŒØ¯. Ø¹Ø¯Ø¯ Ø¨Ø§Ù„Ø§ Ù…Ù…Ú©Ù† Ø§Ø³Øª Ù†Ø´Ø§Ù†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§Ø´Ø¯.">
                        <span class="formula-text">Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¨Ø§Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ÛŒ</span>
                        <p class="formula-description">Ù‡Ø± Ú©Ø±ÙˆÙ† Ø¨Ù‡ Ø·ÙˆØ± Ù…ØªÙˆØ³Ø· Ú†Ù†Ø¯ Ø±Ú©ÙˆØ±Ø¯ Ø±Ø§ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ØŸ</p>
                        <div class="formula-result">${avgLoad}</div>
                    </div>`;
            } else { // queue
                const inflow = config.recordsPerMinute * config.cronInterval;
                const outflow = config.processingCapacity;
                const stability_metric = inflow - outflow;

                 html += `
                    <div class="formula-item" title="Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ù¾Ø§ÛŒØ¯Ø§Ø±ÛŒ ØµÙ Ø±Ø§ Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ (ÙˆØ±ÙˆØ¯ÛŒ Ù…Ù†Ù‡Ø§ÛŒ Ø®Ø±ÙˆØ¬ÛŒ Ø¯Ø± Ù‡Ø± Ø¨Ø§Ø²Ù‡). Ø§Ú¯Ø± Ù…Ø«Ø¨Øª Ø¨Ø§Ø´Ø¯ØŒ ØµÙ Ø¨Ù‡ Ø·ÙˆØ± Ù…Ø¯Ø§ÙˆÙ… Ø±Ø´Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ø³ÛŒØ³ØªÙ… Ù†Ø§Ù¾Ø§ÛŒØ¯Ø§Ø± Ø§Ø³Øª. Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ø¨Ø§ÛŒØ¯ ØµÙØ± ÛŒØ§ Ù…Ù†ÙÛŒ Ø¨Ø§Ø´Ø¯.">
                        <span class="formula-text">Ù¾Ø§ÛŒØ¯Ø§Ø±ÛŒ ØµÙ (Stability)</span>
                        <p class="formula-description">Ø¢ÛŒØ§ ØªØ¹Ø¯Ø§Ø¯ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ø§Ø² Ø¸Ø±ÙÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ù…Ø§ Ø¨ÛŒØ´ØªØ± Ø§Ø³ØªØŸ</p>
                        <div class="${setStatus(stability_metric, v => v > 0, v => v === 0)}">${stability_metric.toFixed(0)}</div>
                    </div>
                     <div class="formula-item" title="Ø§ÛŒÙ† Ù…Ø¹ÛŒØ§Ø± Ù†Ø³Ø¨Øª 'ØªÙˆØ§Ù† Ù¾Ø±Ø¯Ø§Ø²Ø´' Ø¨Ù‡ 'Ø­Ø¬Ù… Ú©Ø§Ø± ÙˆØ±ÙˆØ¯ÛŒ' Ø§Ø³Øª (Ø®Ø±ÙˆØ¬ÛŒ ØªÙ‚Ø³ÛŒÙ… Ø¨Ø± ÙˆØ±ÙˆØ¯ÛŒ). Ø§Ú¯Ø± Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ú©Ù…ØªØ± Ø§Ø² Û± Ø¨Ø§Ø´Ø¯ØŒ Ø³ÛŒØ³ØªÙ… Ù†Ø§Ù¾Ø§ÛŒØ¯Ø§Ø± Ø§Ø³Øª. Ù‡Ø±Ú†Ù‡ Ø§ÛŒÙ† Ø¹Ø¯Ø¯ Ø§Ø² Û± Ø¨Ø²Ø±Ú¯ØªØ± Ø¨Ø§Ø´Ø¯ØŒ Ø³ÛŒØ³ØªÙ… Ø´Ù…Ø§ Ø¨Ø§ Ø­Ø§Ø´ÛŒÙ‡ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø¨ÛŒØ´ØªØ±ÛŒ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯.">
                        <span class="formula-text">Ù†Ø³Ø¨Øª ØªÙˆØ§Ù† Ù¾Ø±Ø¯Ø§Ø²Ø´</span>
                        <p class="formula-description">Ø¢ÛŒØ§ Ø¸Ø±ÙÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ù…Ø§ Ù¾Ø§Ø³Ø®Ú¯ÙˆÛŒ Ø­Ø¬Ù… ÙˆØ±ÙˆØ¯ÛŒ Ù‡Ø³ØªØŸ</p>
                        <div class="formula-result">${inflow > 0 ? (outflow / inflow).toFixed(2) : 'âˆ'}</div>
                    </div>
                    <div class="formula-item" title="Ø§ÛŒÙ† ÙˆØ¶Ø¹ÛŒØª Ø²Ù…Ø§Ù†ÛŒ 'Ø®Ø·Ø±Ù†Ø§Ú©' Ø§Ø³Øª Ú©Ù‡ 'Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ù¾Ø±Ø¯Ø§Ø²Ø´' Ø§Ø² 'ÙØ§ØµÙ„Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø±ÙˆÙ†' Ø¨ÛŒØ´ØªØ± Ø¨Ø§Ø´Ø¯. Ø¯Ø± Ø­Ø§Ù„Øª ØµÙØŒ Ø§ÛŒÙ† Ø§Ù…Ø± Ø¨Ø§Ø¹Ø« Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ú©Ù‡ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¨Ù‡ ØªØ£Ø®ÛŒØ± Ø¨ÛŒÙØªØ¯ Ùˆ ØµÙ Ø¨Ù‡ Ø³Ø±Ø¹Øª Ø±Ø´Ø¯ Ú©Ù†Ø¯.">
                        <span class="formula-text">Ø±ÛŒØ³Ú© Ø§Ø¬Ø±Ø§ÛŒ Ù‡Ù…Ø²Ù…Ø§Ù†</span>
                        <p class="formula-description">Ø¢ÛŒØ§ Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø§ØªÙ…Ø§Ù… Ø§Ø¬Ø±Ø§ÛŒ ÙØ¹Ù„ÛŒ Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŸ</p>
                         <div class="${concurrencyRiskClass}">${concurrencyRisk ? 'Ø®Ø·Ø±Ù†Ø§Ú© âš ï¸' : 'Ø§ÛŒÙ…Ù† âœ…'}</div>
                    </div>
                    <div class="formula-item" title="Ø§ÛŒÙ† Ø¹Ø¯Ø¯ ØªØ®Ù…ÛŒÙ† Ù…ÛŒâ€ŒØ²Ù†Ø¯ Ú©Ù‡ Ø¯Ø± ÙØ§ØµÙ„Ù‡ Ø²Ù…Ø§Ù†ÛŒ Ø¨ÛŒÙ† Ø¯Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø±ÙˆÙ†ØŒ Ú†Ù‡ ØªØ¹Ø¯Ø§Ø¯ Ø¢ÛŒØªÙ… Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ ØµÙ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø§ÛŒÙ† Ù‡Ù…Ø§Ù† 'Ø­Ø¬Ù… Ú©Ø§Ø±ÛŒ' Ø§Ø³Øª Ú©Ù‡ Ù‡Ø± Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø±ÙˆÙ† Ø¨Ø§ÛŒØ¯ Ø¢Ù† Ø±Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù†Ø¯.">
                        <span class="formula-text">ÙˆØ±ÙˆØ¯ÛŒ ØªØ®Ù…ÛŒÙ†ÛŒ Ø¯Ø± Ù‡Ø± Ø¨Ø§Ø²Ù‡</span>
                        <p class="formula-description">Ø¨ÛŒÙ† Ø¯Ùˆ Ø§Ø¬Ø±Ø§ØŒ Ú†Ù†Ø¯ Ø¢ÛŒØªÙ… Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ ØµÙ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŸ</p>
                        <div class="formula-result">${inflow.toFixed(0)}</div>
                    </div>`;
            }
            elements.formulaBox.innerHTML = html;
        }
        // ########### MODIFIED SECTION END ###########

        function updateStats(config, results) {
             let html = `<h3>Ø¢Ù…Ø§Ø± Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ</h3>`;
             if (config.jobType === 'timeWindow') {
                const total = records.length;
                const processed = results.processedRecords.size;
                const missed = results.missedRecords.size;
                const success = total > 0 ? (processed / total * 100) : 0;
                 html += `
                    <div class="stat-item"><span>ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§:</span><span>${total}</span></div>
                    <div class="stat-item"><span>Ù¾Ø±Ø¯Ø§Ø²Ø´â€ŒØ´Ø¯Ù‡:</span><span>${processed}</span></div>
                    <div class="stat-item"><span>Ø§Ø² Ø¯Ø³Øª Ø±ÙØªÙ‡:</span><span>${missed}</span></div>
                    <div class="stat-item"><span>Ø¯Ø±ØµØ¯ Ù…ÙˆÙÙ‚ÛŒØª:</span><span>${success.toFixed(1)}%</span></div>
                    <div class="stat-item"><span>Ø§Ø¬Ø±Ø§Ù‡Ø§ÛŒ Ù†Ø§Ø¯ÛŒØ¯Ù‡â€ŒÚ¯Ø±ÙØªÙ‡â€ŒØ´Ø¯Ù‡:</span><span>${results.skippedRuns}</span></div>`;
             } else { // queue
                 html += `
                    <div class="stat-item"><span>Ú©Ù„ Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ:</span><span>${results.totalAdded}</span></div>
                    <div class="stat-item"><span>Ú©Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´â€ŒØ´Ø¯Ù‡:</span><span>${results.totalProcessed}</span></div>
                    <div class="stat-item"><span>Ø±Ú©ÙˆØ±Ø¯Ù‡Ø§ÛŒ Ù…Ø§Ù†Ø¯Ù‡ Ø¯Ø± ØµÙ:</span><span>${results.finalQueueSize}</span></div>
                    <div class="stat-item"><span>Ø­Ø¯Ø§Ú©Ø«Ø± Ø§Ù†Ø¯Ø§Ø²Ù‡ ØµÙ:</span><span>${results.maxQueueSize}</span></div>
                    <div class="stat-item"><span>Ø§Ø¬Ø±Ø§Ù‡Ø§ÛŒ Ù†Ø§Ø¯ÛŒØ¯Ù‡â€ŒÚ¯Ø±ÙØªÙ‡â€ŒØ´Ø¯Ù‡:</span><span>${results.skippedRuns}</span></div>`;
             }
             elements.stats.innerHTML = html;
        }

        function updateEventLog(logs) {
            elements.eventLogContent.textContent = logs.join('\n');
            elements.eventLogContent.scrollTop = elements.eventLogContent.scrollHeight;
        }

        function drawTimeline(config, results) {
            const { zoom, pan } = timelineState;
            const timelineWidth = elements.timelineContainer.clientWidth * zoom;
            elements.timeline.style.width = `${timelineWidth}px`;
            elements.timeline.style.transform = `translateX(${pan}px)`;
            elements.timeline.innerHTML = '';

            const pxPerMin = timelineWidth / config.simulationTime;

            // Draw time markers
            for (let i = 0; i <= config.simulationTime; i += Math.max(1, Math.floor(config.simulationTime / (20 * zoom)))) {
                const left = i * pxPerMin;
                if (left < -pan || left > -pan + elements.timelineContainer.clientWidth) continue;
                const marker = document.createElement('div');
                marker.style.cssText = `position:absolute; top:0; left:${left}px; width:1px; height:100%; background:var(--border-color); z-index:0;`;
                const label = document.createElement('div');
                label.textContent = i;
                label.style.cssText = `position:absolute; top:2px; left:${left}px; transform:translateX(-50%); font-size:10px;`;
                elements.timeline.appendChild(marker);
                elements.timeline.appendChild(label);
            }

            const createDiv = (className, left, width, tooltip, height = null, bottom = null) => {
                const el = document.createElement('div');
                el.className = className;
                el.style.left = `${left}px`;
                if (width) el.style.width = `${width}px`;
                if (height) el.style.height = `${height}px`;
                if (bottom !== null) el.style.bottom = `${bottom}px`;
                el.dataset.tooltip = tooltip;
                elements.timeline.appendChild(el);
            };

            results.executions.forEach(ex => {
                if (config.jobType === 'timeWindow') {
                    createDiv('processing-window', ex.window[0] * pxPerMin, (ex.window[1] - ex.window[0]) * pxPerMin, `Ø¨Ø§Ø²Ù‡ Ù¾Ø±Ø¯Ø§Ø²Ø´ (Ú©Ø±ÙˆÙ† ${ex.scheduledTime})\nØ´Ø±ÙˆØ¹: ${ex.window[0].toFixed(1)}\nÙ¾Ø§ÛŒØ§Ù†: ${ex.window[1].toFixed(1)}`);
                }
                createDiv('processing-bar', ex.processingStartTime * pxPerMin, (ex.processingEndTime - ex.processingStartTime) * pxPerMin, `Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆØ§Ù‚Ø¹ÛŒ\nØ´Ø±ÙˆØ¹: ${ex.processingStartTime.toFixed(1)}\nÙ¾Ø§ÛŒØ§Ù†: ${ex.processingEndTime.toFixed(1)}`);
                createDiv('cron-execution', ex.actualTime * pxPerMin, null, `Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø±ÙˆÙ†\nØ²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø´Ø¯Ù‡: ${ex.scheduledTime}\nÙˆØ§Ù‚Ø¹ÛŒ: ${ex.actualTime.toFixed(1)}`);
            });
            
            if (config.jobType === 'timeWindow') {
                records.forEach(rec => {
                    createDiv(`record ${rec.status}`, rec.time * pxPerMin, null, `Ø±Ú©ÙˆØ±Ø¯ #${rec.id}\nØ²Ù…Ø§Ù†: ${rec.time.toFixed(1)}\nÙˆØ¶Ø¹ÛŒØª: ${rec.status}`);
                });
            } else { // queue
                const maxQueueSizeForHeight = Math.max(1, results.maxQueueSize);
                const timelineHeight = elements.timeline.clientHeight;
                results.queueSnapshots.forEach((snap, index) => {
                    const nextTime = results.queueSnapshots[index+1]?.time || config.simulationTime;
                    const width = (nextTime - snap.time) * pxPerMin;
                    const height = (snap.size / maxQueueSizeForHeight) * (timelineHeight - 25);
                     createDiv('queue-size-bar', snap.time * pxPerMin, width, `Ø§Ù†Ø¯Ø§Ø²Ù‡ ØµÙ: ${snap.size}\nØ²Ù…Ø§Ù†: ${snap.time}`, height, 0);
                });
            }
        }
        
        // --- Main Controller ---
        function runFullSimulation(shouldGenerateNewRecords = false) {
            const config = getConfig();
            if (config.jobType === 'timeWindow') {
                 if (shouldGenerateNewRecords || records.length === 0) {
                    generateTimeWindowRecords(config);
                }
                simulationResults = runTimeWindowSimulation(config);
            } else { // queue
                simulationResults = runQueueSimulation(config);
            }
            updateUI(config, simulationResults);
        }

        // --- Event Listeners & Setup ---
        function setupEventListeners() {
            // Job type switcher
            elements.jobType.addEventListener('change', (e) => {
                const isTimeWindow = e.target.value === 'timeWindow';
                elements.timeWindowSettings.style.display = isTimeWindow ? 'block' : 'none';
                elements.queueSettings.style.display = isTimeWindow ? 'none' : 'block';
                runFullSimulation(true);
            });
            
            // Link sliders and number inputs
            ['cronInterval', 'processingDuration', 'processStart', 'processEnd', 'jitter'].forEach(id => {
                elements[id].addEventListener('input', () => {
                    elements[`${id}Number`].value = elements[id].value;
                    elements[`${id}Value`].textContent = elements[id].value;
                    runFullSimulation();
                });
                elements[`${id}Number`].addEventListener('input', () => {
                    elements[id].value = elements[`${id}Number`].value;
                     elements[`${id}Value`].textContent = elements[id].value;
                    runFullSimulation();
                });
            });

            // General controls that trigger simulation
            ['concurrencyMode', 'simulationTime', 'recordCount', 'recordDistribution', 'recordsPerMinute', 'processingCapacity'].forEach(id => {
                 elements[id].addEventListener('change', () => runFullSimulation(true));
            });

            // Timeline interaction (unchanged)
             elements.timelineContainer.addEventListener('mousedown', (e) => {
                timelineState.isDragging = true;
                timelineState.startX = e.pageX - timelineState.pan;
                elements.timelineContainer.style.cursor = 'grabbing';
            });
            window.addEventListener('mouseup', () => {
                timelineState.isDragging = false;
                elements.timelineContainer.style.cursor = 'grab';
            });
            window.addEventListener('mousemove', (e) => {
                if (!timelineState.isDragging) return;
                e.preventDefault();
                timelineState.pan = e.pageX - timelineState.startX;
                drawTimeline(getConfig(), simulationResults);
            });
            elements.timelineContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = elements.timelineContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseTime = (mouseX - timelineState.pan) / (elements.timeline.offsetWidth / getConfig().simulationTime);
                const zoomFactor = 1.1;
                if (e.deltaY < 0) timelineState.zoom *= zoomFactor;
                else timelineState.zoom /= zoomFactor;
                timelineState.zoom = Math.max(1, Math.min(50, timelineState.zoom));
                timelineState.pan = mouseX - (mouseTime * (elements.timelineContainer.clientWidth * timelineState.zoom / getConfig().simulationTime));
                drawTimeline(getConfig(), simulationResults);
            });

            // Tooltip (unchanged)
            elements.timeline.addEventListener('mouseover', e => {
                if (e.target.dataset.tooltip) {
                    elements.tooltip.style.display = 'block';
                    elements.tooltip.textContent = e.target.dataset.tooltip;
                }
            });
            elements.timeline.addEventListener('mouseout', () => elements.tooltip.style.display = 'none');
            elements.timeline.addEventListener('mousemove', e => {
                elements.tooltip.style.left = `${e.clientX + 15}px`;
                elements.tooltip.style.top = `${e.clientY + 15}px`;
            });

            // Dark Mode (unchanged)
            elements.darkModeToggle.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                elements.darkModeToggle.textContent = document.body.classList.contains('dark-mode') ? 'â˜€ï¸ Ø­Ø§Ù„Øª Ø±ÙˆØ´Ù†' : 'ğŸŒ™ Ø­Ø§Ù„Øª ØªØ§Ø±ÛŒÚ©';
            });
            
            // JSON Export
            elements.exportJson.addEventListener('click', () => {
                 const config = getConfig();
                 const dataToExport = {
                    config: config,
                    results: {
                        ...simulationResults,
                        // Convert Sets to Arrays for JSON compatibility
                        processedRecords: simulationResults.processedRecords ? Array.from(simulationResults.processedRecords) : undefined,
                        missedRecords: simulationResults.missedRecords ? Array.from(simulationResults.missedRecords) : undefined
                    }
                };
                 if (config.jobType === 'timeWindow') {
                    dataToExport.records = records;
                 }

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dataToExport, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "cron_simulation_results.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            });
        }
        
        // Initial Run
        window.onload = () => {
            setupEventListeners();
            // Set initial label values from default input values
            ['cronInterval', 'processingDuration', 'processStart', 'processEnd', 'jitter'].forEach(id => {
                elements[`${id}Value`].textContent = elements[id].value;
                elements[`${id}Number`].value = elements[id].value;
            });
            runFullSimulation(true);
        };
        window.onresize = () => runFullSimulation();
    </script>
</body>
</html>