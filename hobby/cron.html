<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>شبیه‌ساز کرون‌جاب</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --container-bg: white;
            --text-color: #333;
            --border-color: #ddd;
            --control-bg: #f8f9fa;
            --shadow-color: rgba(0,0,0,0.1);
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --safe-color: #28a745;
            --critical-color: #ffc107;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
        }

        body.dark-mode {
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --border-color: #444;
            --control-bg: #2a2a2a;
            --shadow-color: rgba(0,0,0,0.4);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 20px;
            background: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--container-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px var(--shadow-color);
            border: 1px solid var(--border-color);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        h1 { margin: 0; }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        fieldset {
            background: var(--control-bg);
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 8px;
        }

        legend {
            font-weight: bold;
            padding: 0 10px;
            color: var(--primary-color);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .control-group label {
            font-weight: 500;
        }
        
        input[type="number"], select {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--container-bg);
            color: var(--text-color);
            width: 100%;
            box-sizing: border-box;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-group input[type="range"] {
            flex-grow: 1;
        }
        
        button {
            padding: 10px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        button:hover { background: var(--primary-hover); }

        .button-group {
            display: flex;
            gap: 10px;
            grid-column: 1 / -1; /* Span all columns */
            margin-top: 10px;
        }
        
        .formula-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        .formula-box h3 {
            grid-column: 1 / -1;
            margin: 0 0 10px 0;
            text-align: center;
        }
        .formula-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        .formula-text {
            font-size: 14px;
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .formula-description {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.85);
            margin: 5px 0 10px 0;
            flex-grow: 1; /* Allows items to have same height */
        }
        .formula-result {
            font-size: 18px; font-weight: bold; padding: 5px 10px; border-radius: 4px;
        }
        .result-safe { background: var(--safe-color); color: white; }
        .result-critical { background: var(--critical-color); color: #212529; }
        .result-danger { background: var(--danger-color); color: white; }
        
        .timeline-container {
            width: 100%;
            overflow-x: hidden; /* Managed by JS */
            cursor: grab;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
        }
        .timeline {
            height: 150px;
            position: relative;
            background: linear-gradient(to right, var(--control-bg) 0%, var(--container-bg) 100%);
        }
        
        .cron-execution {
            position: absolute; width: 3px; background: var(--danger-color); top: 25px; height: calc(100% - 25px); z-index: 4;
        }
        .processing-window {
            position: absolute; background: rgba(40, 167, 69, 0.2); border: 1px dashed var(--safe-color); top: 25px; height: calc(100% - 25px); z-index: 1;
        }
        .processing-bar {
            position: absolute; background: rgba(23, 162, 184, 0.6); border: 1px solid var(--info-color); top: 35px; height: 10px; z-index: 2;
        }
        .record {
            position: absolute; width: 10px; height: 10px; border-radius: 50%; top: 60px; z-index: 3; transform: translateX(-50%);
        }
        .record.pending { background: var(--critical-color); border: 2px solid #ff6b35; }
        .record.processed { background: var(--safe-color); border: 2px solid #155724; }
        .record.missed { background: var(--danger-color); border: 2px solid #721c24; animation: pulse 1s infinite; }
        .queue-size-bar {
            position: absolute; background: rgba(255, 193, 7, 0.4); border-top: 2px solid var(--critical-color); bottom: 0; z-index: 0;
        }
        
        .stats-logs-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .stats, .event-log {
            background: var(--control-bg); padding: 15px; border-radius: 8px;
        }
        .event-log pre {
            max-height: 200px; overflow-y: auto; background: var(--bg-color); padding: 10px; border-radius: 4px; font-size: 12px;
        }
        .stat-item { display: flex; justify-content: space-between; margin: 8px 0; }
        
        .tooltip {
            position: fixed; background: #333; color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 9999; display: none; white-space: pre; pointer-events: none;
        }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>شبیه‌ساز حرفه‌ای کرون جاب</h1>
            <button id="darkModeToggle">🌙 حالت تاریک</button>
        </div>
        
        <div class="controls">
            <fieldset>
                <legend>تنظیمات عمومی کرون</legend>
                 <div class="control-group">
                    <label for="jobType">نوع وظیفه (Job Type):</label>
                    <select id="jobType">
                        <option value="timeWindow" selected>پردازش بازه زمانی (Time Window)</option>
                        <option value="queue">پردازش صف (Queue)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="cronInterval">فاصله اجرای کرون (دقیقه): <span id="cronIntervalValue">5</span></label>
                    <div class="slider-group">
                        <input type="range" id="cronInterval" value="5" min="1" max="60">
                        <input type="number" id="cronIntervalNumber" value="5" min="1" max="60">
                    </div>
                </div>
                 <div class="control-group">
                    <label for="processingDuration">مدت زمان پردازش (دقیقه): <span id="processingDurationValue">2</span></label>
                    <div class="slider-group">
                        <input type="range" id="processingDuration" value="2" min="0" max="30" step="0.5">
                        <input type="number" id="processingDurationNumber" value="2" min="0" max="30" step="0.5">
                    </div>
                </div>
                 <div class="control-group">
                    <label for="concurrencyMode">رفتار در زمان تداخل اجرا:</label>
                    <select id="concurrencyMode">
                        <option value="skip" selected>نادیده گرفتن (Skip)</option>
                        <option value="queue">صف (Queue)</option>
                    </select>
                </div>
                 <div class="control-group">
                    <label for="jitter">حداکثر تأخیر تصادفی (Jitter): <span id="jitterValue">0</span></label>
                    <div class="slider-group">
                        <input type="range" id="jitter" value="0" min="0" max="5" step="0.1">
                        <input type="number" id="jitterNumber" value="0" min="0" max="5" step="0.1">
                    </div>
                </div>
            </fieldset>

            <div id="timeWindowSettings">
                <fieldset>
                    <legend>تنظیمات بازه پردازش</legend>
                    <div class="control-group">
                        <label for="processStart">شروع بازه پردازش (دقیقه پیش): <span id="processStartValue">7</span></label>
                        <div class="slider-group">
                             <input type="range" id="processStart" value="7" min="1" max="60">
                             <input type="number" id="processStartNumber" value="7" min="1" max="60">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="processEnd">پایان بازه پردازش (دقیقه پیش): <span id="processEndValue">10</span></label>
                        <div class="slider-group">
                            <input type="range" id="processEnd" value="10" min="1" max="60">
                            <input type="number" id="processEndNumber" value="10" min="1" max="60">
                        </div>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>تنظیمات رکوردهای بازه زمانی</legend>
                    <div class="control-group">
                        <label for="recordCount">تعداد کل رکوردها:</label>
                        <input type="number" id="recordCount" value="80" min="10" max="500">
                    </div>
                    <div class="control-group">
                        <label for="recordDistribution">الگوی توزیع رکوردها:</label>
                        <select id="recordDistribution">
                            <option value="uniform" selected>یکنواخت (Uniform)</option>
                            <option value="bursty">خوشه‌ای (Bursty)</option>
                            <option value="normal">نرمال (Normal)</option>
                        </select>
                    </div>
                </fieldset>
            </div>

            <fieldset id="queueSettings" style="display: none;">
                <legend>تنظیمات پردازش صف</legend>
                <div class="control-group">
                    <label for="recordsPerMinute">رکوردهای ورودی به صف (در دقیقه):</label>
                    <input type="number" id="recordsPerMinute" value="15" min="1" max="500">
                </div>
                <div class="control-group">
                    <label for="processingCapacity">ظرفیت پردازش در هر اجرا (تعداد رکورد):</label>
                    <input type="number" id="processingCapacity" value="50" min="1" max="1000">
                </div>
            </fieldset>

            <fieldset>
                 <legend>تنظیمات شبیه‌سازی</legend>
                 <div class="control-group">
                    <label for="simulationTime">مدت زمان شبیه‌سازی (دقیقه):</label>
                    <input type="number" id="simulationTime" value="60" min="30" max="500">
                </div>
            </fieldset>
            
            <div class="button-group">
                 <button onclick="runFullSimulation(false)">🔄 اجرای مجدد شبیه‌سازی</button>
                 <button onclick="runFullSimulation(true)">🎲 تولید رکورد/سناریو جدید و اجرا</button>
                 <button id="exportJson">📄 دانلود نتایج (JSON)</button>
            </div>
        </div>
        
           <div class="formula-box" id="formulaBox">
                <!-- Content will be generated by JS -->
           </div>
        
        <div class="timeline-container" id="timelineContainer">
            <div class="timeline" id="timeline"></div>
        </div>
        
        <div class="stats-logs-container">
            <div class="stats" id="stats">
                <!-- Content will be generated by JS -->
            </div>
            <div class="event-log">
                <h3>لاگ رویدادها</h3>
                <pre id="eventLogContent">برای مشاهده لاگ، شبیه‌سازی را اجرا کنید.</pre>
            </div>
        </div>
    </div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // DOM Elements
        const elements = {};
        const ids = [
            'jobType', 'cronInterval', 'cronIntervalValue', 'cronIntervalNumber', 'processingDuration', 'processingDurationValue', 'processingDurationNumber',
            'concurrencyMode', 'processStart', 'processStartValue', 'processStartNumber', 'processEnd', 'processEndValue', 'processEndNumber',
            'recordCount', 'simulationTime', 'recordDistribution', 'jitter', 'jitterValue', 'jitterNumber',
            'formulaBox', 'timelineContainer', 'timeline', 'stats',
            'eventLogContent', 'tooltip', 'darkModeToggle', 'exportJson',
            'timeWindowSettings', 'queueSettings', 'recordsPerMinute', 'processingCapacity'
        ];
        ids.forEach(id => elements[id] = document.getElementById(id));

        // Global State
        let records = [];
        let simulationResults = {};
        let timelineState = { zoom: 1, pan: 0, isDragging: false, startX: 0 };

        // --- Configuration Reading ---
        function getConfig() {
            const config = {
                jobType: elements.jobType.value,
                cronInterval: parseFloat(elements.cronInterval.value),
                simulationTime: parseInt(elements.simulationTime.value),
                processingDuration: parseFloat(elements.processingDuration.value),
                concurrencyMode: elements.concurrencyMode.value,
                jitter: parseFloat(elements.jitter.value)
            };
            
            if (config.jobType === 'timeWindow') {
                config.processStart = parseFloat(elements.processStart.value);
                config.processEnd = parseFloat(elements.processEnd.value);
                config.recordCount = parseInt(elements.recordCount.value);
                config.recordDistribution = elements.recordDistribution.value;
            } else { // queue
                config.recordsPerMinute = parseInt(elements.recordsPerMinute.value);
                config.processingCapacity = parseInt(elements.processingCapacity.value);
            }
            return config;
        }

        // --- Core Simulation Logic ---
        function generateTimeWindowRecords(config) {
            records = [];
            for (let i = 0; i < config.recordCount; i++) {
                let time;
                switch (config.recordDistribution) {
                    case 'normal':
                        let u, v;
                        do { u = Math.random() * 2 - 1; v = Math.random() * 2 - 1; } while (u * u + v * v >= 1);
                        let rand_std = u * Math.sqrt(-2 * Math.log(u * u + v * v) / (u * u + v * v));
                        let rand_norm = (config.simulationTime / 2) + (config.simulationTime / 6) * rand_std;
                        time = Math.max(0, Math.min(config.simulationTime, rand_norm));
                        break;
                    case 'bursty':
                        const numBursts = Math.max(2, Math.floor(config.simulationTime / 20));
                        const burstCenter = (Math.floor(Math.random() * numBursts) + 1) * (config.simulationTime / (numBursts + 1));
                        time = burstCenter + (Math.random() - 0.5) * (config.simulationTime / 10);
                        time = Math.max(0, Math.min(config.simulationTime, time));
                        break;
                    default:
                        time = Math.random() * config.simulationTime;
                        break;
                }
                records.push({ id: i, time: time, status: 'pending' });
            }
            records.sort((a, b) => a.time - b.time);
        }

        function runTimeWindowSimulation(config) {
            records.forEach(r => r.status = 'pending');
            
            const results = {
                executions: [],
                processedRecords: new Set(),
                missedRecords: new Set(),
                logs: [],
                skippedRuns: 0
            };

            let processingEndTime = 0;
            
            for (let time = config.cronInterval; time <= config.simulationTime; time += config.cronInterval) {
                const actualExecTime = time + (Math.random() * config.jitter);
                let processingStartTime = actualExecTime;

                if (config.concurrencyMode === 'skip' && actualExecTime < processingEndTime) {
                    results.skippedRuns++;
                    results.logs.push(`[${actualExecTime.toFixed(1)}] 🏃‍♂️ CRON SKIPPED due to ongoing process.`);
                    continue;
                }
                
                if (config.concurrencyMode === 'queue' && actualExecTime < processingEndTime) {
                    processingStartTime = processingEndTime;
                     results.logs.push(`[${actualExecTime.toFixed(1)}] 🕒 CRON QUEUED. Will start at ${processingStartTime.toFixed(1)}.`);
                }
                
                const currentProcessingEndTime = processingStartTime + config.processingDuration;
                processingEndTime = currentProcessingEndTime;

                const windowStart = actualExecTime - config.processEnd;
                const windowEnd = actualExecTime - config.processStart;
                
                const executionData = {
                    scheduledTime: time,
                    actualTime: actualExecTime,
                    processingStartTime: processingStartTime,
                    processingEndTime: currentProcessingEndTime,
                    window: [windowStart, windowEnd],
                    processed: []
                };

                results.logs.push(`[${actualExecTime.toFixed(1)}] ⚡️ CRON EXECUTED. Window: [${windowStart.toFixed(1)}, ${windowEnd.toFixed(1)}]`);

                records.forEach(record => {
                    if (record.status === 'pending' && record.time >= windowStart && record.time < windowEnd) {
                        record.status = 'processed';
                        results.processedRecords.add(record.id);
                        executionData.processed.push(record.id);
                        results.logs.push(`  - ✅ Record #${record.id} at ${record.time.toFixed(1)} processed.`);
                    }
                });
                results.executions.push(executionData);
            }

            const finalSafeTime = results.executions.length > 0 ? results.executions[results.executions.length - 1].actualTime - config.processStart : config.simulationTime;
            records.forEach(record => {
                if (record.status === 'pending' && record.time < finalSafeTime) {
                    record.status = 'missed';
                    results.missedRecords.add(record.id);
                     results.logs.push(`[${record.time.toFixed(1)}] ❌ Record #${record.id} MISSED.`);
                }
            });

            return results;
        }

        function runQueueSimulation(config) {
            let queueSize = 0;
            let totalAdded = 0;
            let totalProcessed = 0;
            let maxQueueSize = 0;
            let processingEndTime = 0;
            
            const results = {
                executions: [],
                logs: [],
                skippedRuns: 0,
                queueSnapshots: []
            };
            
            for (let t = 1; t <= config.simulationTime; t++) {
                const addedThisMinute = config.recordsPerMinute; // Simplified: constant rate
                queueSize += addedThisMinute;
                totalAdded += addedThisMinute;
                if (queueSize > maxQueueSize) maxQueueSize = queueSize;
                
                if (t % config.cronInterval === 0) {
                    const scheduledTime = t;
                    const actualExecTime = scheduledTime + (Math.random() * config.jitter);
                    let processingStartTime = actualExecTime;
                    
                    if (config.concurrencyMode === 'skip' && actualExecTime < processingEndTime) {
                        results.skippedRuns++;
                        results.logs.push(`[${actualExecTime.toFixed(1)}] 🏃‍♂️ CRON SKIPPED. Queue size: ${queueSize}`);
                        continue;
                    }
                    if (config.concurrencyMode === 'queue' && actualExecTime < processingEndTime) {
                        processingStartTime = processingEndTime;
                        results.logs.push(`[${actualExecTime.toFixed(1)}] 🕒 CRON QUEUED. Will start at ${processingStartTime.toFixed(1)}. Queue size: ${queueSize}`);
                    }

                    const currentProcessingEndTime = processingStartTime + config.processingDuration;
                    processingEndTime = currentProcessingEndTime;
                    
                    const processedThisRun = Math.min(queueSize, config.processingCapacity);
                    queueSize -= processedThisRun;
                    totalProcessed += processedThisRun;

                    const executionData = {
                        scheduledTime: scheduledTime,
                        actualTime: actualExecTime,
                        processingStartTime: processingStartTime,
                        processingEndTime: currentProcessingEndTime,
                        processedCount: processedThisRun,
                        queueSizeBefore: queueSize + processedThisRun
                    };
                    results.executions.push(executionData);
                    results.queueSnapshots.push({ time: scheduledTime, size: queueSize + processedThisRun });
                    results.logs.push(`[${actualExecTime.toFixed(1)}] ⚡️ CRON EXECUTED. Processed ${processedThisRun} items. Queue size: ${queueSize}`);
                }
            }
            
            results.totalAdded = totalAdded;
            results.totalProcessed = totalProcessed;
            results.finalQueueSize = queueSize;
            results.maxQueueSize = maxQueueSize;
            return results;
        }


        // --- UI Update Functions ---
        function updateUI(config, results) {
            updateFormulas(config, results);
            updateStats(config, results);
            drawTimeline(config, results);
            updateEventLog(results.logs);
        }

        function setStatus(val, danger, critical) {
            if (danger(val)) return 'formula-result result-danger';
            if (critical(val)) return 'formula-result result-critical';
            return 'formula-result result-safe';
        }

        // ########### MODIFIED SECTION START ###########
        function updateFormulas(config, results) {
            let html = `<h3>🧮 تحلیل فرمولی و پیش‌بینی ریسک</h3>`;

            const concurrencyRisk = config.processingDuration > config.cronInterval;
            const concurrencyRiskClass = setStatus(concurrencyRisk, v => v, () => false);
            
            if (config.jobType === 'timeWindow') {
                const gap = (config.cronInterval + config.processStart) - config.processEnd;
                const maxSafe = config.processEnd - config.processStart;
                const totalProcessed = results.processedRecords ? results.processedRecords.size : 0;
                const totalExecutions = results.executions ? results.executions.length : 0;
                const avgLoad = totalExecutions > 0 ? (totalProcessed / totalExecutions).toFixed(1) : 0;

                html += `
                    <div class="formula-item" title="این عدد نشان‌دهنده 'شکاف زمانی' بین بازه‌های پردازش است. اگر این عدد مثبت باشد، یک شکاف به وجود می‌آید که رکوردهای داخل آن هرگز پردازش نخواهند شد. برای پردازش کامل، این عدد باید صفر یا منفی باشد.">
                        <span class="formula-text">شکاف پردازش (Gap)</span>
                        <p class="formula-description">آیا زمانی وجود دارد که هیچ کرونی آن را پوشش نمی‌دهد؟</p>
                        <div class="${setStatus(gap, v => v > 0, v => v === 0)}">${gap.toFixed(1)}</div>
                    </div>
                    <div class="formula-item" title="این عدد بیشترین فاصله زمانی است که می‌توانید بین دو اجرای کرون داشته باشید بدون اینکه هیچ رکوردی از دست برود. فاصله اجرای کرون شما باید کمتر یا مساوی این عدد باشد. این مقدار معادل طول پنجره پردازش شما (End - Start) است.">
                        <span class="formula-text">حداکثر فاصله اجرای ایمن</span>
                        <p class="formula-description">برای جلوگیری از شکاف، فاصله کرون حداکثر چقدر باید باشد؟</p>
                        <div class="${setStatus(config.cronInterval, v => v > maxSafe, v => v === maxSafe)}">${maxSafe.toFixed(1)}</div>
                    </div>
                    <div class="formula-item" title="این وضعیت زمانی 'خطرناک' است که 'مدت زمان پردازش' از 'فاصله اجرای کرون' بیشتر باشد. این می‌تواند منجر به اجرای همزمان کرون‌ها، مصرف بیش از حد منابع سرور یا پردازش دوباره داده‌ها شود.">
                        <span class="formula-text">ریسک اجرای همزمان</span>
                        <p class="formula-description">آیا اجرای بعدی قبل از اتمام اجرای فعلی شروع می‌شود؟</p>
                         <div class="${concurrencyRiskClass}">${concurrencyRisk ? 'خطرناک ⚠️' : 'ایمن ✅'}</div>
                    </div>
                    <div class="formula-item" title="این معیار میانگین تعداد رکوردهایی است که در هر اجرای موفق کرون پردازش می‌شود. این عدد به شما کمک می‌کند ظرفیت سیستم خود را تخمین بزنید. عدد بالا ممکن است نشان‌دهنده نیاز به بهینه‌سازی باشد.">
                        <span class="formula-text">میانگین بار پردازشی</span>
                        <p class="formula-description">هر کرون به طور متوسط چند رکورد را پردازش می‌کند؟</p>
                        <div class="formula-result">${avgLoad}</div>
                    </div>`;
            } else { // queue
                const inflow = config.recordsPerMinute * config.cronInterval;
                const outflow = config.processingCapacity;
                const stability_metric = inflow - outflow;

                 html += `
                    <div class="formula-item" title="این عدد پایداری صف را نشان می‌دهد (ورودی منهای خروجی در هر بازه). اگر مثبت باشد، صف به طور مداوم رشد می‌کند و سیستم ناپایدار است. این عدد باید صفر یا منفی باشد.">
                        <span class="formula-text">پایداری صف (Stability)</span>
                        <p class="formula-description">آیا تعداد آیتم‌های ورودی از ظرفیت پردازش شما بیشتر است؟</p>
                        <div class="${setStatus(stability_metric, v => v > 0, v => v === 0)}">${stability_metric.toFixed(0)}</div>
                    </div>
                     <div class="formula-item" title="این معیار نسبت 'توان پردازش' به 'حجم کار ورودی' است (خروجی تقسیم بر ورودی). اگر این عدد کمتر از ۱ باشد، سیستم ناپایدار است. هرچه این عدد از ۱ بزرگتر باشد، سیستم شما با حاشیه اطمینان بیشتری کار می‌کند.">
                        <span class="formula-text">نسبت توان پردازش</span>
                        <p class="formula-description">آیا ظرفیت پردازش شما پاسخگوی حجم ورودی هست؟</p>
                        <div class="formula-result">${inflow > 0 ? (outflow / inflow).toFixed(2) : '∞'}</div>
                    </div>
                    <div class="formula-item" title="این وضعیت زمانی 'خطرناک' است که 'مدت زمان پردازش' از 'فاصله اجرای کرون' بیشتر باشد. در حالت صف، این امر باعث می‌شود که پردازش به تأخیر بیفتد و صف به سرعت رشد کند.">
                        <span class="formula-text">ریسک اجرای همزمان</span>
                        <p class="formula-description">آیا اجرای بعدی قبل از اتمام اجرای فعلی شروع می‌شود؟</p>
                         <div class="${concurrencyRiskClass}">${concurrencyRisk ? 'خطرناک ⚠️' : 'ایمن ✅'}</div>
                    </div>
                    <div class="formula-item" title="این عدد تخمین می‌زند که در فاصله زمانی بین دو اجرای کرون، چه تعداد آیتم جدید به صف اضافه می‌شود. این همان 'حجم کاری' است که هر اجرای کرون باید آن را مدیریت کند.">
                        <span class="formula-text">ورودی تخمینی در هر بازه</span>
                        <p class="formula-description">بین دو اجرا، چند آیتم جدید به صف اضافه می‌شود؟</p>
                        <div class="formula-result">${inflow.toFixed(0)}</div>
                    </div>`;
            }
            elements.formulaBox.innerHTML = html;
        }
        // ########### MODIFIED SECTION END ###########

        function updateStats(config, results) {
             let html = `<h3>آمار شبیه‌سازی</h3>`;
             if (config.jobType === 'timeWindow') {
                const total = records.length;
                const processed = results.processedRecords.size;
                const missed = results.missedRecords.size;
                const success = total > 0 ? (processed / total * 100) : 0;
                 html += `
                    <div class="stat-item"><span>تعداد کل رکوردها:</span><span>${total}</span></div>
                    <div class="stat-item"><span>پردازش‌شده:</span><span>${processed}</span></div>
                    <div class="stat-item"><span>از دست رفته:</span><span>${missed}</span></div>
                    <div class="stat-item"><span>درصد موفقیت:</span><span>${success.toFixed(1)}%</span></div>
                    <div class="stat-item"><span>اجراهای نادیده‌گرفته‌شده:</span><span>${results.skippedRuns}</span></div>`;
             } else { // queue
                 html += `
                    <div class="stat-item"><span>کل رکوردهای ورودی:</span><span>${results.totalAdded}</span></div>
                    <div class="stat-item"><span>کل پردازش‌شده:</span><span>${results.totalProcessed}</span></div>
                    <div class="stat-item"><span>رکوردهای مانده در صف:</span><span>${results.finalQueueSize}</span></div>
                    <div class="stat-item"><span>حداکثر اندازه صف:</span><span>${results.maxQueueSize}</span></div>
                    <div class="stat-item"><span>اجراهای نادیده‌گرفته‌شده:</span><span>${results.skippedRuns}</span></div>`;
             }
             elements.stats.innerHTML = html;
        }

        function updateEventLog(logs) {
            elements.eventLogContent.textContent = logs.join('\n');
            elements.eventLogContent.scrollTop = elements.eventLogContent.scrollHeight;
        }

        function drawTimeline(config, results) {
            const { zoom, pan } = timelineState;
            const timelineWidth = elements.timelineContainer.clientWidth * zoom;
            elements.timeline.style.width = `${timelineWidth}px`;
            elements.timeline.style.transform = `translateX(${pan}px)`;
            elements.timeline.innerHTML = '';

            const pxPerMin = timelineWidth / config.simulationTime;

            // Draw time markers
            for (let i = 0; i <= config.simulationTime; i += Math.max(1, Math.floor(config.simulationTime / (20 * zoom)))) {
                const left = i * pxPerMin;
                if (left < -pan || left > -pan + elements.timelineContainer.clientWidth) continue;
                const marker = document.createElement('div');
                marker.style.cssText = `position:absolute; top:0; left:${left}px; width:1px; height:100%; background:var(--border-color); z-index:0;`;
                const label = document.createElement('div');
                label.textContent = i;
                label.style.cssText = `position:absolute; top:2px; left:${left}px; transform:translateX(-50%); font-size:10px;`;
                elements.timeline.appendChild(marker);
                elements.timeline.appendChild(label);
            }

            const createDiv = (className, left, width, tooltip, height = null, bottom = null) => {
                const el = document.createElement('div');
                el.className = className;
                el.style.left = `${left}px`;
                if (width) el.style.width = `${width}px`;
                if (height) el.style.height = `${height}px`;
                if (bottom !== null) el.style.bottom = `${bottom}px`;
                el.dataset.tooltip = tooltip;
                elements.timeline.appendChild(el);
            };

            results.executions.forEach(ex => {
                if (config.jobType === 'timeWindow') {
                    createDiv('processing-window', ex.window[0] * pxPerMin, (ex.window[1] - ex.window[0]) * pxPerMin, `بازه پردازش (کرون ${ex.scheduledTime})\nشروع: ${ex.window[0].toFixed(1)}\nپایان: ${ex.window[1].toFixed(1)}`);
                }
                createDiv('processing-bar', ex.processingStartTime * pxPerMin, (ex.processingEndTime - ex.processingStartTime) * pxPerMin, `پردازش واقعی\nشروع: ${ex.processingStartTime.toFixed(1)}\nپایان: ${ex.processingEndTime.toFixed(1)}`);
                createDiv('cron-execution', ex.actualTime * pxPerMin, null, `اجرای کرون\nزمانبندی شده: ${ex.scheduledTime}\nواقعی: ${ex.actualTime.toFixed(1)}`);
            });
            
            if (config.jobType === 'timeWindow') {
                records.forEach(rec => {
                    createDiv(`record ${rec.status}`, rec.time * pxPerMin, null, `رکورد #${rec.id}\nزمان: ${rec.time.toFixed(1)}\nوضعیت: ${rec.status}`);
                });
            } else { // queue
                const maxQueueSizeForHeight = Math.max(1, results.maxQueueSize);
                const timelineHeight = elements.timeline.clientHeight;
                results.queueSnapshots.forEach((snap, index) => {
                    const nextTime = results.queueSnapshots[index+1]?.time || config.simulationTime;
                    const width = (nextTime - snap.time) * pxPerMin;
                    const height = (snap.size / maxQueueSizeForHeight) * (timelineHeight - 25);
                     createDiv('queue-size-bar', snap.time * pxPerMin, width, `اندازه صف: ${snap.size}\nزمان: ${snap.time}`, height, 0);
                });
            }
        }
        
        // --- Main Controller ---
        function runFullSimulation(shouldGenerateNewRecords = false) {
            const config = getConfig();
            if (config.jobType === 'timeWindow') {
                 if (shouldGenerateNewRecords || records.length === 0) {
                    generateTimeWindowRecords(config);
                }
                simulationResults = runTimeWindowSimulation(config);
            } else { // queue
                simulationResults = runQueueSimulation(config);
            }
            updateUI(config, simulationResults);
        }

        // --- Event Listeners & Setup ---
        function setupEventListeners() {
            // Job type switcher
            elements.jobType.addEventListener('change', (e) => {
                const isTimeWindow = e.target.value === 'timeWindow';
                elements.timeWindowSettings.style.display = isTimeWindow ? 'block' : 'none';
                elements.queueSettings.style.display = isTimeWindow ? 'none' : 'block';
                runFullSimulation(true);
            });
            
            // Link sliders and number inputs
            ['cronInterval', 'processingDuration', 'processStart', 'processEnd', 'jitter'].forEach(id => {
                elements[id].addEventListener('input', () => {
                    elements[`${id}Number`].value = elements[id].value;
                    elements[`${id}Value`].textContent = elements[id].value;
                    runFullSimulation();
                });
                elements[`${id}Number`].addEventListener('input', () => {
                    elements[id].value = elements[`${id}Number`].value;
                     elements[`${id}Value`].textContent = elements[id].value;
                    runFullSimulation();
                });
            });

            // General controls that trigger simulation
            ['concurrencyMode', 'simulationTime', 'recordCount', 'recordDistribution', 'recordsPerMinute', 'processingCapacity'].forEach(id => {
                 elements[id].addEventListener('change', () => runFullSimulation(true));
            });

            // Timeline interaction (unchanged)
             elements.timelineContainer.addEventListener('mousedown', (e) => {
                timelineState.isDragging = true;
                timelineState.startX = e.pageX - timelineState.pan;
                elements.timelineContainer.style.cursor = 'grabbing';
            });
            window.addEventListener('mouseup', () => {
                timelineState.isDragging = false;
                elements.timelineContainer.style.cursor = 'grab';
            });
            window.addEventListener('mousemove', (e) => {
                if (!timelineState.isDragging) return;
                e.preventDefault();
                timelineState.pan = e.pageX - timelineState.startX;
                drawTimeline(getConfig(), simulationResults);
            });
            elements.timelineContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = elements.timelineContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseTime = (mouseX - timelineState.pan) / (elements.timeline.offsetWidth / getConfig().simulationTime);
                const zoomFactor = 1.1;
                if (e.deltaY < 0) timelineState.zoom *= zoomFactor;
                else timelineState.zoom /= zoomFactor;
                timelineState.zoom = Math.max(1, Math.min(50, timelineState.zoom));
                timelineState.pan = mouseX - (mouseTime * (elements.timelineContainer.clientWidth * timelineState.zoom / getConfig().simulationTime));
                drawTimeline(getConfig(), simulationResults);
            });

            // Tooltip (unchanged)
            elements.timeline.addEventListener('mouseover', e => {
                if (e.target.dataset.tooltip) {
                    elements.tooltip.style.display = 'block';
                    elements.tooltip.textContent = e.target.dataset.tooltip;
                }
            });
            elements.timeline.addEventListener('mouseout', () => elements.tooltip.style.display = 'none');
            elements.timeline.addEventListener('mousemove', e => {
                elements.tooltip.style.left = `${e.clientX + 15}px`;
                elements.tooltip.style.top = `${e.clientY + 15}px`;
            });

            // Dark Mode (unchanged)
            elements.darkModeToggle.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                elements.darkModeToggle.textContent = document.body.classList.contains('dark-mode') ? '☀️ حالت روشن' : '🌙 حالت تاریک';
            });
            
            // JSON Export
            elements.exportJson.addEventListener('click', () => {
                 const config = getConfig();
                 const dataToExport = {
                    config: config,
                    results: {
                        ...simulationResults,
                        // Convert Sets to Arrays for JSON compatibility
                        processedRecords: simulationResults.processedRecords ? Array.from(simulationResults.processedRecords) : undefined,
                        missedRecords: simulationResults.missedRecords ? Array.from(simulationResults.missedRecords) : undefined
                    }
                };
                 if (config.jobType === 'timeWindow') {
                    dataToExport.records = records;
                 }

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dataToExport, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "cron_simulation_results.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            });
        }
        
        // Initial Run
        window.onload = () => {
            setupEventListeners();
            // Set initial label values from default input values
            ['cronInterval', 'processingDuration', 'processStart', 'processEnd', 'jitter'].forEach(id => {
                elements[`${id}Value`].textContent = elements[id].value;
                elements[`${id}Number`].value = elements[id].value;
            });
            runFullSimulation(true);
        };
        window.onresize = () => runFullSimulation();
    </script>
</body>
</html>